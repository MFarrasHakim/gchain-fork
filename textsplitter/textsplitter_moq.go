// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package textsplitter

import (
	"sync"
)

// Ensure, that TextSplitterMock does implement TextSplitter.
// If this is not the case, regenerate this file with moq.
var _ TextSplitter = &TextSplitterMock{}

// TextSplitterMock is a mock implementation of TextSplitter.
//
//	func TestSomethingThatUsesTextSplitter(t *testing.T) {
//
//		// make and configure a mocked TextSplitter
//		mockedTextSplitter := &TextSplitterMock{
//			LenFunc: func(input string) int {
//				panic("mock out the Len method")
//			},
//			SplitTextFunc: func(input string, maxChunkSize int, overlap int) []string {
//				panic("mock out the SplitText method")
//			},
//		}
//
//		// use mockedTextSplitter in code that requires TextSplitter
//		// and then make assertions.
//
//	}
type TextSplitterMock struct {
	// LenFunc mocks the Len method.
	LenFunc func(input string) int

	// SplitTextFunc mocks the SplitText method.
	SplitTextFunc func(input string, maxChunkSize int, overlap int) []string

	// calls tracks calls to the methods.
	calls struct {
		// Len holds details about calls to the Len method.
		Len []struct {
			// Input is the input argument value.
			Input string
		}
		// SplitText holds details about calls to the SplitText method.
		SplitText []struct {
			// Input is the input argument value.
			Input string
			// MaxChunkSize is the maxChunkSize argument value.
			MaxChunkSize int
			// Overlap is the overlap argument value.
			Overlap int
		}
	}
	lockLen       sync.RWMutex
	lockSplitText sync.RWMutex
}

// Len calls LenFunc.
func (mock *TextSplitterMock) Len(input string) int {
	if mock.LenFunc == nil {
		panic("TextSplitterMock.LenFunc: method is nil but TextSplitter.Len was just called")
	}
	callInfo := struct {
		Input string
	}{
		Input: input,
	}
	mock.lockLen.Lock()
	mock.calls.Len = append(mock.calls.Len, callInfo)
	mock.lockLen.Unlock()
	return mock.LenFunc(input)
}

// LenCalls gets all the calls that were made to Len.
// Check the length with:
//
//	len(mockedTextSplitter.LenCalls())
func (mock *TextSplitterMock) LenCalls() []struct {
	Input string
} {
	var calls []struct {
		Input string
	}
	mock.lockLen.RLock()
	calls = mock.calls.Len
	mock.lockLen.RUnlock()
	return calls
}

// SplitText calls SplitTextFunc.
func (mock *TextSplitterMock) SplitText(input string, maxChunkSize int, overlap int) []string {
	if mock.SplitTextFunc == nil {
		panic("TextSplitterMock.SplitTextFunc: method is nil but TextSplitter.SplitText was just called")
	}
	callInfo := struct {
		Input        string
		MaxChunkSize int
		Overlap      int
	}{
		Input:        input,
		MaxChunkSize: maxChunkSize,
		Overlap:      overlap,
	}
	mock.lockSplitText.Lock()
	mock.calls.SplitText = append(mock.calls.SplitText, callInfo)
	mock.lockSplitText.Unlock()
	return mock.SplitTextFunc(input, maxChunkSize, overlap)
}

// SplitTextCalls gets all the calls that were made to SplitText.
// Check the length with:
//
//	len(mockedTextSplitter.SplitTextCalls())
func (mock *TextSplitterMock) SplitTextCalls() []struct {
	Input        string
	MaxChunkSize int
	Overlap      int
} {
	var calls []struct {
		Input        string
		MaxChunkSize int
		Overlap      int
	}
	mock.lockSplitText.RLock()
	calls = mock.calls.SplitText
	mock.lockSplitText.RUnlock()
	return calls
}
